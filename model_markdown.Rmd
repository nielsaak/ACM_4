
## Load packages

```{r}
pacman::p_load(tidyverse,
               here,
               posterior,
               cmdstanr,
               brms, 
               tidybayes, 
               loo,
               sigmoid,
               future,
               furrr,
               purrr)
```

## Visualise data for descriptive statistics

### Load data

```{r}
data <- read.csv("data/AlienData.txt",
                header = TRUE)

# Filter for the right session
filtered_data <- data[data$session == 1, ]

# Filter for condition for now
filtered_data <- data[data$condition == 1, ]

view(filtered_data)

length(unique(filtered_data$subject))

df <- filtered_data
```

### Visualise

```{r}
# Visualisations

# Category
ggplot(df, aes(x = as.factor(category))) +
  geom_bar() +
  labs(x = "Category", y = "Count", title = "Distribution of Categories") +
  theme_minimal()

# Response
ggplot(df, aes(x = as.factor(response))) +
  geom_bar() +
  labs(x = "Response", y = "Count", title = "Distribution of Responses") +
  theme_minimal()

# Response vs category
confusion_matrix <- df %>% # Create a confusion matrix/table
  group_by(category, response) %>%
  summarise(Count = n()) %>%
  ungroup()

ggplot(confusion_matrix, aes(x = response, y = category, fill = Count)) + # Create a heatmap
  geom_tile(color = "white") +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(x = "Response", y = "Category", title = "Category vs Response", fill = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # Rotate x labels for readability

# Reaction time
# Filter for everything below 50.000
rt_df <- df[df$RT <= 50000, ]

ggplot(rt_df, aes(x = RT)) +
  geom_histogram(binwidth = 50, fill = "blue", color = "black") +
  labs(x = "Reaction Time (RT)", y = "Frequency", title = "Histogram of Reaction Times") +
  theme_minimal()
```

## Simulate conditions and features

```{r}
feat_1 <- c(0,1) # spots
feat_2 <- c(0,1) # eyes
feat_3 <- c(0,1)
feat_4 <- c(0,1) # arms
feat_5 <- c(0,1)

stimuli <- expand.grid(feat_1 = feat_1, feat_2 = feat_2, feat_3 = feat_3, feat_4 = feat_4, feat_5 = feat_5)
stimuli <- rbind(stimuli[sample(nrow(stimuli)),],stimuli[sample(nrow(stimuli)),],stimuli[sample(nrow(stimuli)),])

danger <- ifelse((stimuli$feat_1 == 1) & (stimuli$feat_2 == 1), 1, 0)
nutri <- ifelse((stimuli$feat_4 == 1), 1, 0)
```

## Calculate distance and similarity

```{r}
# Distance
distance <- function(vect1, vect2, w) {
  return(sum(w * abs(vect1 - vect2)))
}

# Similarity
similarity <- function(distance, c) {
  return(exp(-c * distance))
}
```

```{r}
# Investigating the distances
distance_list_eq <- c()
distance_list_w1 <- c()
distance_list_w2 <- c()

for (i in 1:nrow(stimuli)){
  for (j in 1:nrow(stimuli)){
    distance_list_eq <- c(distance_list_eq, distance(stimuli[i,], stimuli[j,], rep(1/5,5)))
    distance_list_w1 <- c(distance_list_w1, distance(stimuli[i,], stimuli[j,], c(1/2,1/2,0,0,0)))
    distance_list_w2 <- c(distance_list_w2, distance(stimuli[i,], stimuli[j,], c(0,0,3/10,3/10,4/10)))
  }
}

plot(distance_list_eq)
plot(distance_list_w1)
plot(distance_list_w2)
```
## GCM

```{r}
### Generative model (infinite memory) ###
gcm <- function(w, c, obs, cat_one, quiet = TRUE) {
  # Create an empty list to save probability of saying "1" for each trial
  r <- c()
  
  ntrials <- nrow(obs)
  
  for (i in 1:ntrials) {
    # If quiet is FALSE, print every ten trials
    if (!quiet && i %% 10 == 0) {
      print(paste("i =", i))
    }
    # If this is the first trial, or there any category with no exemplars seen yet, set the choice to random
    if (i == 1 || sum(cat_one[1:(i - 1)]) == 0 || sum(cat_one[1:(i - 1)]) == (i - 1)) {
      r <- c(r, .5)
    } else {
      similarities <- c()
      # For each previously seen stimulus assess distance and similarity
      for (e in 1:(i - 1)) {
        sim <- similarity(distance(obs[i, ], obs[e, ], w), c)
        similarities <- c(similarities, sim)
      }
      # Calculate prob of saying "1" by dividing similarity to 1 by the sum of similarity to 1 and to 2
      numerator <- mean(similarities[cat_one[1:(i - 1)] == 1])
      denominator <- mean(similarities[cat_one[1:(i - 1)] == 1]) + mean(similarities[cat_one[1:(i - 1)] == 0])
      r <- c(r, numerator / denominator)
    }
  }

  return(rbinom(ntrials, 1, r))
}

### Generative model (limited memory) (not used) ###
gcm_lim <- function(w, c, obs, cat_one, quiet = TRUE, memory) {
  # Create an empty list to save probability of saying "1" for each trial
  r <- c()
  
  ntrials <- nrow(obs)
  
  for (i in 1:ntrials) {
    low_mem <- (relu(i-(memory+1))+1)
    # If quiet is FALSE, print every ten trials
    if (!quiet && i %% 10 == 0) {
      print(paste("i =", i))
    }
    # If this is the first trial, or there any category with no exemplars seen yet, set the choice to random
    if (i == 1 || sum(cat_one[low_mem:(i - 1)]) == 0 || sum(cat_one[low_mem:(i - 1)]) == (i - low_mem)) {
      r <- c(r, .5)
    } else {
      similarities <- c()
      # For the previous 5 stimulus assess distance and similarity
      # relu(i-(memory+1))+1 is a way of achieving a memory = memory
      for (e in low_mem:(i - 1)) {
        sim <- similarity(distance(obs[i, ], obs[e, ], w), c)
        similarities <- c(similarities, sim)
      }
      # Calculate prob of saying "1" by dividing similarity to 1 by the sum of similarity to 1 and to 2
      numerator <- mean(similarities[cat_one[low_mem:(i - 1)] == 1])
      denominator <- mean(similarities[cat_one[low_mem:(i - 1)] == 1]) + mean(similarities[cat_one[low_mem:(i - 1)] == 0])
      r <- c(r, numerator / denominator)
    }
  }

  return(rbinom(ntrials, 1, r))
}
```

```{r}
# Testing the function
simulated_data_inf_mem <- tibble(trial = seq(nrow(stimuli)),
                         sim_response = gcm(
                           w = rep(1/5, 5), 
                           c = 2,
                           obs = stimuli,
                           cat_one = danger),
                         danger = danger,
                         correct = ifelse(danger == sim_response, 1, 0),
                         c = 4,
                         w = 1/5)

# simulated_data_lim_mem <- tibble(trial = seq(nrow(stimuli)),
#                          sim_response = gcm_lim(
#                            w = rep(1/5, 5), 
#                            c = 2,
#                            obs = stimuli,
#                            cat_one = danger,
#                            memory = 5),
#                          danger = danger,
#                          correct = ifelse(danger == sim_response, 1, 0),
#                          c = 2,
#                          w = 1/5)

simulated_data_inf_mem$cumsum_correct <- cumsum(simulated_data_inf_mem$correct)/seq_along(simulated_data_inf_mem$correct)
# simulated_data_lim_mem$cumsum_correct <- cumsum(simulated_data_lim_mem$correct)/seq_along(simulated_data_lim_mem$correct)

simulated_data_inf_mem %>% 
  ggplot(aes(x = trial, y = cumsum_correct)) +
  geom_line(aes(colour = "Inf_mem")) +
  # geom_line(aes(y = simulated_data_lim_mem$cumsum_correct,colour = " Lim_mem")) +
  ggtitle("Cumulative rate of correct responses for one participant (Inf Memory)")
```

## Simulating responses
Simulates responses of multiple agents to randomized stimuli under various weighting and scaling configurations

```{r}
# Multiple agents across different parameters
# Function for simulation responses
simulate_responses <- function(agent, w, c) {
  
    stimuli_temp <- stimuli
    stimuli_temp$danger <- danger
    shuffled_stim <- stimuli_temp[sample(nrow(stimuli_temp)),]
    shuffled_stim_ <- shuffled_stim %>% 
      select(-danger)
    danger_ <- shuffled_stim %>% 
      select(danger) %>% 
      unlist()
  
    if (w == "equal") {
        weight <- rep(1 / 5, 5)
    } else if (w == "skewed1") {
        weight <- c(1/2,1/2,0,0,0)
    } else if (w == "skewed2") {
        weight <- c(0,0,3/10,3/10,4/10)
    }

    # Simulate responses
    responses <- gcm(
        weight,
        c,
        shuffled_stim_,
        danger_
    )
    
    df_temp <- tibble(trial = seq(nrow(shuffled_stim_)),
                         sim_response = responses,
                         danger_col = danger_,
                         correct = ifelse(danger_col == sim_response, 1, 0),
                         performance = cumsum(correct) / seq_along(correct),
                         c = c,
                         w = w,
                         agent = agent)
    
    df_temp <- cbind(df_temp, shuffled_stim_)
    
    return(df_temp)
}


# Simulate responses
plan(multisession, workers = availableCores())

param_df <- dplyr::tibble(
    expand_grid(
        agent = 1:5,
        c = seq(.5, 5, 0.5),
        w = c("equal", "skewed1", "skewed2")
    )
)

simulated_responses <- future_pmap_dfr(param_df,
    simulate_responses,
    .options = furrr_options(seed = TRUE),
    .progress = TRUE
)
```

### Plotting the simulated responses

```{r}
p3 <- simulated_responses %>%
  mutate(w = as.factor(w)) %>%
  ggplot(aes(trial, performance, group = w, color = w)) +
  geom_smooth() +
  theme_bw() +
  facet_wrap(c ~ .)

p4 <- simulated_responses %>%
  mutate(c = as.factor(c)) %>%
  ggplot(aes(trial, performance, group = c, color = c)) +
  geom_smooth() +
  theme_bw() +
  facet_wrap(w ~ .)

p3
p4
```
### Comparing to real agents

```{r}
# Compare to real agents
df <- read_csv("data/AlienData.txt")

df <- df %>% 
  filter(condition == 1, session == 1) %>% 
  group_by(subject) %>% 
  mutate(performance = cumsum(correct) / seq_along(correct))

df %>% 
  ggplot(aes(trial, performance, colour = as.factor(subject))) +
  geom_smooth() +
  theme_bw()

```

## Single-level simulated parameter recovery

```{r}
# Compiling model
gcm_model <- cmdstan_model("stan/gcm_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r}
weights_sim <- c(1/2,1/2,0,0,0)
# weights_sim <- rep(1/5, 5)
# weights_sim <- c(0,0,3/10,3/10,4/10)
c_val <- 3

stimuli_sim <- rbind(stimuli)
danger_sim <- c(danger)

simulated_data_inf_mem <- tibble(trial = seq(nrow(stimuli_sim)),
                                 sim_response = gcm(
                                   w = weights_sim, 
                                   c = c_val,
                                   obs = stimuli_sim,
                                   cat_one = danger_sim),
                                 danger_col = danger_sim,
                                 correct = ifelse(danger_col == sim_response, 1, 0))

data_gcm_Bayes <- list(
  ntrials = nrow(simulated_data_inf_mem),
  nfeatures = 5,
  cat_one = danger_sim,
  y = simulated_data_inf_mem$sim_response,
  obs = as.matrix(stimuli_sim),
  b = 0.5,
  w_prior_values = c(1,1,1,1,1), # used in the dirichlet distribution, so <lower=1>
  c_prior_values = c(0,1) # mean and standard deviation for logit normal distribution
  )

samples <- gcm_model$sample(
   data = data_gcm_Bayes,
   seed = 123,
   chains =4,
   parallel_chains = 4,
   threads_per_chain = 2,
   iter_warmup = 2000,
   iter_sampling = 2000,
   refresh =1000,
   max_treedepth = 20,
   adapt_delta = 0.99,
)
```

### Printing the output

```{r}
samples$summary()
```

```{r}
draws_df <- as_draws_df(samples$draws())

ggplot(draws_df, aes(.iteration, c, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, logit_c, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[1]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[2]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[3]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[4]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[5]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df) +
  geom_histogram(aes(c), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(c_prior), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = c_val) +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[1]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[1]`), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weights_sim[1]) +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[2]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[2]`), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weights_sim[2]) +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[3]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[3]`), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weights_sim[3]) +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[4]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[4]`), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weights_sim[4]) +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[5]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[5]`), alpha = 0.6, fill = "pink") +
  geom_vline(xintercept = weights_sim[5]) +
  theme_bw()

draws_df %>% 
  mutate(all_but_w1 = `w[2]`+`w[3]`+`w[4]`+`w[5]`) %>% 
  ggplot() +
  geom_point(aes(`w[1]`, all_but_w1), alpha = 0.6, color = "lightblue") +
  theme_bw()

ggplot(draws_df) +
  geom_point(aes(c, `w[1]`), alpha = 0.6, color = "lightblue") +
  theme_bw()

ggplot(draws_df) +
  geom_point(aes(c, `w[2]`), alpha = 0.6, color = "lightblue") +
  theme_bw()

ggplot(draws_df) +
  geom_point(aes(c, `w[3]`), alpha = 0.6, color = "lightblue") +
  theme_bw()

ggplot(draws_df) +
  geom_point(aes(c, `w[4]`), alpha = 0.6, color = "lightblue") +
  theme_bw()

ggplot(draws_df) +
  geom_point(aes(c, `w[5]`), alpha = 0.6, color = "lightblue") +
  theme_bw()

ggplot(draws_df) +
  geom_point(aes(`w[1]`, `w[2]`), alpha = 0.6, color = "lightblue") +
  theme_bw()

```

## Full Parameter Recovery

```{r}
plan(multisession, workers = availableCores())

sim_d_and_fit <- function(agent, scaling, weights) {
  
    
    temp <- simulated_responses %>% subset(
      c == scaling & w == weights & agent == agent
      )
    
    data <- list(
      ntrials = nrow(temp),
      nfeatures = 5,
      cat_one = temp$danger_col,
      y = temp$sim_response,
      obs = as.matrix(temp[, c("feat_1", "feat_2", "feat_3", "feat_4", "feat_5")]),
      b = 0.5, 
      w_prior_values = c(1, 1, 1, 1, 1),
      c_prior_values = c(0, 1)
    )
    
    samples_gcm <- gcm_model$sample(
      data = data,
      seed = 123,
      chains = 1,
      parallel_chains = 1,
      threads_per_chain = 4,
      iter_warmup = 1000,
      iter_sampling = 1000,
      refresh = 500
    )
    
    draws_df <- as_draws_df(samples_gcm$draws()) 
    temp <- tibble(trueC = scaling, trueW = weights, agent = agent,
                   estC = draws_df$c, 
                   estW1 = draws_df$`w[1]`,
                   estW2 = draws_df$`w[2]`,
                   estW3 = draws_df$`w[3]`,
                   estW4 = draws_df$`w[4]`,
                   estW5 = draws_df$`w[5]`
                   )
    
    return(temp)
  
}


temp <- tibble(unique(simulated_responses[,c("agent", "c", "w")])) %>%
  rename(
    scaling = c,
    weights = w
  )

recovery_df <- future_pmap_dfr(temp, sim_d_and_fit, .options = furrr_options(seed = TRUE), .progress = TRUE)

write_csv(recovery_df, "output/gcm_parameter_recovery.csv")

```

```{r}
recovery_df %>% 
  ggplot(aes(x = estC, y = trueC)) +
  geom_point() +
  geom_abline() +
  facet_wrap(~trueW)

# TODO: more plots
```


## Multi-level simulated parameter recovery (archived)

```{r}
# agents <- 25
# scalingM <- 1
# scalingSD <- 0.1
# weights <- c(49/100,48/100,1/100,1/100,1/100)
# kappa <- 1
# 
# simulate_responses <- function(agent, w, c) {
#   
#     # stimuli_temp <- stimuli
#     # stimuli_temp$danger <- danger
#     # shuffled_stim <- stimuli_temp[sample(nrow(stimuli_temp)),]
#     # shuffled_stim_ <- shuffled_stim %>% 
#     #   select(-danger)
#     # danger_ <- shuffled_stim %>% 
#     #   select(danger) %>% 
#     #   unlist()
# 
#     # simulate responses
#     responses <- gcm(
#         w,
#         c,
#         stimuli,
#         danger
#     )
#     
#     df_temp <- tibble(trial = seq(nrow(stimuli)),
#                          sim_response = responses,
#                          danger_col = danger,
#                          correct = ifelse(danger_col == sim_response, 1, 0),
#                          performance = cumsum(correct) / seq_along(correct),
#                          c = c,
#                          w1 = weights[1],
#                          w2 = weights[2],
#                          w3 = weights[3],
#                          w4 = weights[4],
#                          w5 = weights[5],
#                          agent = agent)
#     
#     df_temp <- cbind(df_temp, stimuli)
#     
#     return(df_temp)
# }
# 
# d <- simulate_responses(agents, weights, scalingM)
# 
# ## Then we make sure to simulate n agents
# 
# simulate_ml_responses <- function(agents, scalingM, scalingSD, weights, kappa) {
#   w_ind <- rdirichlet(agents, weights * kappa)
#   c_ind <- rnorm(agents, scalingM, scalingSD)
#   
#   for (i in 1:agents) {
#     tmp <- simulate_responses(i, w = c(w_ind[i,1:5]), c = c_ind[i])
#     if (i == 1) {
#       simulated_responses <- tmp
#     } else {
#       simulated_responses <- rbind(simulated_responses, tmp)
#     }
#   }
#   
#   return(simulated_responses)
# }
# 
# # Simulate and visualize
# 
# d <- simulate_ml_responses(agents, scalingM, scalingSD, weights, kappa)
# 
# ggplot(d, aes(trial, performance)) +
#   geom_smooth() +
#   geom_line(aes(group = agent, color = agent)) +
#   theme_bw()
# ```
# 
# ```{r}
# # Compiling model
# gcm_multi_model <- cmdstan_model("stan/gcm_multi_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
# ```
# 
# ```{r}
# ## Fit the simulated data
# d1 <- d[,c("agent","trial","sim_response")] %>% pivot_wider(
#   names_from = agent,
#   values_from = c(sim_response))
# 
# gcm_ml_data <- list(
#   nsubjects = agents,
#   ntrials = nrow(stimuli),
#   nfeatures = 5,
#   cat_one = danger,
#   y = as.matrix(d1[, 2:(agents + 1)]),
#   obs = as.matrix(stimuli[, c("feat_1", "feat_2", "feat_3", "feat_4", "feat_5")]),
#   b = 0.5,
#   w_prior_values = c(1,1,1,1,1),
#   c_prior_values = c(0, 1)
# )
# 
# samples_gcm_ml <- gcm_multi_model$sample(
#   data = gcm_ml_data,
#   seed = 123,
#   chains = 2,
#   parallel_chains = 2,
#   threads_per_chain = 2,
#   iter_warmup = 1000,
#   iter_sampling = 1000,
#   refresh = 1000
# )
```

## Parameter estimation

```{r}
df <- read_csv("data/AlienData.txt")

df <- df %>% 
  filter(condition == 1, session == 1) %>% 
  mutate(resp_dan = ifelse((response == 3)|(response==4), 1, 0)) %>% 
  mutate(correct_dan = ifelse(resp_dan == dangerous, 1, 0)) %>% 
  group_by(subject) %>% 
  mutate(performance_dan = cumsum(correct_dan) / seq_along(correct_dan)) %>% 
  filter(!str_detect(stimulus, "pt"))
```

```{r}
# Compiling model
gcm_model <- cmdstan_model("stan/gcm_bayesian.stan", cpp_options = list(stan_threads = TRUE), pedantic = TRUE)
```

```{r}
# These are already defined above, just copied them here again, so I don't have to run every chunk
feat_1 <- c(0,1) # spots
feat_2 <- c(0,1) # eyes
feat_3 <- c(0,1)
feat_4 <- c(0,1) # arms
feat_5 <- c(0,1)
stimuli <- expand.grid(feat_1 = feat_1, feat_2 = feat_2, feat_3 = feat_3, feat_4 = feat_4, feat_5 = feat_5)
stimuli <- rbind(stimuli[sample(nrow(stimuli)),],stimuli[sample(nrow(stimuli)),],stimuli[sample(nrow(stimuli)),])

danger <- ifelse((stimuli$feat_1 == 1) & (stimuli$feat_2 == 1), 1, 0)
nutri <- ifelse((stimuli$feat_4 == 1), 1, 0)

danger_sim <- c(danger)
stimuli_sim <- rbind(stimuli)

# Loop through subjects
results <- list()
for (subject_id in unique(df$subject)) {
  # Filter data for the current subject
  subject_data <- df %>% filter(subject == subject_id)
  
  # You may need to adjust how 'sim_response' is being assigned if this is supposed to vary per participant
  data_gcm_Bayes <- list(
    ntrials = nrow(subject_data),
    nfeatures = 5,
    cat_one = danger_sim,  # This should align with how stimuli are set for each trial
    y = subject_data$correct_dan,  # Assuming this is the response
    obs = as.matrix(stimuli_sim),
    b = 0.5,
    w_prior_values = c(1, 1, 1, 1, 1),
    c_prior_values = c(0, 1)
  )

  samples <- gcm_model$sample(
    data = data_gcm_Bayes,
    seed = 123,
    chains = 4,
    parallel_chains = 4,
    threads_per_chain = 2,
    iter_warmup = 2000,
    iter_sampling = 2000,
    refresh = 1000,
    max_treedepth = 20,
    adapt_delta = 0.99
  )
  
  print('Subject: ', subject_id)
  
  results[[subject_id]] <- samples
}
```

```{r}
# Check convergence for one of the models (e.g., the first subject)
print(results[[1]]$summary(c("parameters")))
```

```{r}
# Calculate mean of parameter estimates across all subjects
param_means <- lapply(results, function(x) as.data.frame(x$summary(c("parameters"))) %>% summarise_all(mean))
mean_w1 <- mean(sapply(param_means, function(x) x["w[1]", "mean"]))
mean_c <- mean(sapply(param_means, function(x) x["c", "mean"]))

print(mean_w1)
print(mean_c)
```


```{r}
draws_df <- as_draws_df(samples$draws())

ggplot(draws_df, aes(.iteration, c, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, logit_c, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[1]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[2]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[3]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[4]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df, aes(.iteration, `w[5]`, group = .chain, color = .chain)) +
  geom_line(alpha = 0.5) +
  theme_classic()

ggplot(draws_df) +
  geom_histogram(aes(c), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(c_prior), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[1]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[1]`), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[2]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[2]`), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[3]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[3]`), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[4]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[4]`), alpha = 0.6, fill = "pink") +
  theme_bw()

ggplot(draws_df) +
  geom_histogram(aes(`w[5]`), alpha = 0.6, fill = "lightblue") +
  geom_histogram(aes(`w_prior[5]`), alpha = 0.6, fill = "pink") +
  theme_bw()
```

